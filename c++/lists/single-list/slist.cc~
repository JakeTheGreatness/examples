/*
 *  implement a single linked list.
 */

#include <slist.h>
#include <cassert>


/*
 *  slist - constructor, builds an empty list.
 *          pre-condition:    none.
 *          post-condition:   list is created and is empty.
 */

slist::slist (void)
  : head_element(0)
{
}


/*
 *  ~slist - deconstructor, releases the memory attached to the list.
 *           pre-condition:    none.
 *           post-condition:   list is empty.
 */

slist::~slist (void)
{
  while (head_element != 0) {
    element *t = head_element;
    head_element = head_element->next;
    delete t;
  }
  head_element = 0;
}


/*
 *  empty - returns a new empty list.
 *          pre-condition:   none.
 *          post-condition:  a new empty list is returned.
 */

slist slist::empty (void)
{
  slist *l = new slist;
  return *l;
}


/*
 *  is_empty - returns true if list is empty.
 */

bool slist::is_empty (void)
{
  return head_element == 0;
}


/*
 *  cons - concatenate i to slist.
 *         pre-condition:   none.
 *         post-condition:  returns the list which has i at its head
 *                          and the remainer of contents as, slist.
 */

slist slist::cons (int i)
{
  element *e = new element;

  e->data = i;
  e->next = head_element;
  head_element = e;
  return *this;
}


/*
 *  head - returns the data at the front of the list.
 *         pre-condition :  slist is not empty.
 *         post-condition:  data at the front of the list is returned.
 *                          slist is unchanged.
 */

int slist::head (void)
{
  assert (! is_empty());
  return head_element->data;
}


/*
 *  tail - opposite of cons.  Remove the head value and return
 *         the remainder of the list.
 *         pre-condition:   non empty list.
 *         post-condition:  return the list without the first element.
 */

slist slist::tail (void)
{
  element *e = head_element;

  assert (! is_empty());
  head_element = head_element->next;
  delete e;
  return *this;
}
